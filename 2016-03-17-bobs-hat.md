---
layout: post
title: "bob's hat, Boston Key Party 2016 CTF"
date: 2016-03-17
categories: [ctf-writeups, crypto] 
description: having fun with all types of weird RSA properties 
toc: true
---

```
Alice and Bob are close together, likely because they 
have a lot of things in common.
This is why Alice asked him a small *q*uestion, 
about something cooler than a wiener.
```

Some obvious highlights (*close together*, *things in common*, *small q*, *weiner*, and a provided public key file) show we're talking about RSA and attacks against it.

### almost_almost_almost_almost_there
We start with three files:

```
almost_almost_almost_almost_there.encrypted
almost_almost_almost_almost_there.pub
almost_almost_almost_almost_there.zip
```

*almost_almost_almost_almost_there.zip* is encrypted.  *almost_almost_almost_almost_there.pub* has a 1024-bit modulus, which could take a while to factor with NFS.  Fermat factorization makes short work of it in this case:

```python
# Thanks to djb for saving my ass (as always) with crypto problems
# http://facthacks.cr.yp.to/fermat.htm
def fermatfactor(N):  
    if N <= 0: return [N]
    if is_even(N): return [2,N/2]
    a = ceil(sqrt(N))
    while not is_square(a^2-N):
      a = a + 1
    b = sqrt(a^2-N)
    return [a - b,a + b]

sage: e
65537
sage: n
94738740796943840961823530695778701408987757287583492665919730017973847138345511139064596113422435977583856843887008168202003855906708039013487349390571801141407245039011598810542232029634564848797998534872251549660454277336502838185642937637576121533945369150901808833844341421315429263207612372324026271327L
sage: p,q = fermatfactor(n)
sage: p
9733382803370256893136109840971590971460094779242334919432347801491641617443615856221168611138933576118196795282443503609663168324106758595642231987245583
sage: q
9733382803370256893136109840971590971460094779242334919432347801491641617443615856221168611138933576118196795282443503609663168324106758595642231987246769
sage: f = open('almost_almost_almost_almost_there.encrypted', 'r')
sage: print privkey.decrypt(f.read())
XtCgoEKksjKFWlqOSxqsEhK/+tsr1k5c
```


### almost_almost_almost_there

Another 1024-bit public key:

```python
sage: pubkey.e
65537L
sage: pubkey.n
120711743009219994199387876852052728633821823282001686682637390852879151974458145267822911849735028484705409995093556556200794256334281726827362237024436514832093260227632662199484927313901600908887456085422513604165959261958989999918526241413568697980750606419722847183884466865579933961646797811650439499767L
```

Now that we have two public keys (the first one given for free, and this one), we can try the *things in common* hint:

```python
sage: p = gcd(pubkey.n, prev_pubkey.n)
sage: p
9733382803370256893136109840971590971460094779242334919432347801491641617443615856221168611138933576118196795282443503609663168324106758595642231987246769
```

With one common prime factor, we're in:

```python
sage: d = inverse_mod(pubkey.e, (p-1)*(pubkey.n/p-1))
sage: privkey = RSA.construct((long(pubkey.n), long(pubkey.e), long(d)))
sage: f = open('almost_almost_almost_there.encrypted', 'r')
sage: print privkey.decrypt(f.read())
rlSpJ6HbP+cZXaOuSPOe4pgfevGnXtLt
```


### almost_almost_there

Another public key:

```python
sage: pubkey.e
65537L
sage: pubkey.n
8597656297860545107091403497608238810415884857788354623649545462584626186357491015183008751788834205126626170046660764709588721169432974804650110624299531971774114543254422558416305578835040900745856782965785268333750404184841766134544089627917308591465828618442384534122739386366913053748919149466237339278512341L
sage: pubkey.n.bit_length()
1040
```

Slightly longer key this time.  We've used *things in common*, what about *small q*?

```python
sage: for i in xrange(3, 10000000000000000, 2):
          if pubkey.n % i == 0:
              print i
              break
....:
54311
sage: q = 54311
sage: p = pubkey.n / q
sage: d = inverse_mod(pubkey.e, (p-1)*(q-1))
sage: privkey = RSA.construct((long(pubkey.n),long(pubkey.e),long(d)))
sage: f = open('almost_almost_there.encrypted', 'r')
sage: print privkey.decrypt(f.read())
hQdK+dKleMJqth/dofWyFaiWp3PW7jil
```


### almost_there

Next (final?) key:

```python
sage: pubkey.e
49446678600051379228760906286031155509742239832659705731559249988210578539211813543612425990507831160407165259046991194935262200565953842567148786053040450198919753834397378188932524599840027093290217612285214105791999673535556558448523448336314401414644879827127064929878383237432895170442176211946286617205L
sage: pubkey.n
109676931776753394141394564514720734236796584022842820507613945978304098920529412415619708851314423671483225500317195833435789174491417871864260375066278885574232653256425434296113773973874542733322600365156233965235292281146938652303374751525426102732530711430473466903656428846184387282528950095967567885381L
```

Large `e`.  Wiener attack.  Threw a python implementation at it (thanks to MSLC, I believe I ripped it from them a year ago):

```bash
$ ~/code/wiener_attack.py -n 109676931776753394141394564514720734236796584022842820507613945978304098920529412415619708851314423671483225500317195833435789174491417871864260375066278885574232653256425434296113773973874542733322600365156233965235292281146938652303374751525426102732530711430473466903656428846184387282528950095967567885381 -e 49446678600051379228760906286031155509742239832659705731559249988210578539211813543612425990507831160407165259046991194935262200565953842567148786053040450198919753834397378188932524599840027093290217612285214105791999673535556558448523448336314401414644879827127064929878383237432895170442176211946286617205
-p 10114792273660656874618568712406420344176220457790563178092222929337786916374923318745284718351487926620784106195715878875311958793629905453919697155685507
-q 10843221374140991753173625949764386011485161421520044246309105053489500519257941272796681417497061734054081478280518835582353321569961722963922828311576983
-e 49446678600051379228760906286031155509742239832659705731559249988210578539211813543612425990507831160407165259046991194935262200565953842567148786053040450198919753834397378188932524599840027093290217612285214105791999673535556558448523448336314401414644879827127064929878383237432895170442176211946286617205
```

And then...

```python
sage: p = 10114792273660656874618568712406420344176220457790563178092222929337786916374923318745284718351487926620784106195715878875311958793629905453919697155685507
sage: q = 10843221374140991753173625949764386011485161421520044246309105053489500519257941272796681417497061734054081478280518835582353321569961722963922828311576983
sage: d = inverse_mod(pubkey.e, (p-1)*(q-1))
sage: privkey = RSA.construct((long(pubkey.n),long(pubkey.e),long(d)))
sage: f = open('almost_there.encrypted', 'r')
sage: print privkey.decrypt(f.read())
/3aAP5dF2zmrPh9K6A4AqMLsIiYDk2C2
```

Which gives us the final zip password to extract the `FLAG` file:

```bash
~/code/ctfs/bkp2016/crypto/bobs-hat $ cat FLAG
BKPCTF{Its_not_you,_its_rsa_(that_is_broken)}
```

